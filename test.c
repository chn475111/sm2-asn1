#include <errno.h>
#include <string.h>
#include "sm2_asn1.h"

#ifndef PRINT_HEX
#define PRINT_HEX(buf, len)                                                                 \
    do{                                                                                     \
        if(buf != NULL && len > 0)                                                          \
        {                                                                                   \
            int loop = 0;                                                                   \
            for(loop = 0; loop < len; loop++)                                               \
                printf("0x%02hhx%s", buf[loop], (loop+1) % 16 != 0 ? ", " : ",\n");         \
            printf("\n");                                                                   \
        }                                                                                   \
    }while(0);
#endif

// SM2加密
static int xCoordinateLen = 0;
static unsigned char xCoordinate[2048] = {
    0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
    0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10
};

static int yCoordinateLen = 0;
static unsigned char yCoordinate[2048] = {
    0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
    0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80
};

static int hashLen = 0;
static unsigned char hash[2048] = {
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
};

static int cipherTextLen = 0;
static unsigned char cipherText[2048] = {
    0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08
};

static int sm2cipherLen = 0;
static unsigned char sm2cipher[2048] = {0};

// SM2签名
static int rLen = 0;
static unsigned char r[2048] = {
    0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30,
    0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30
};

static int sLen = 0;
static unsigned char s[2048] = {
    0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0,
    0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0
};

static int sm2signatureLen = 0;
static unsigned char sm2signature[2048] = {0};

// SM2信封
static int symAlgIDLen = 0;
static unsigned char symAlgID[2048] = {
    0x2a, 0x81, 0x1c, 0xcf, 0x55, 0x01, 0x68
};

static int symEncryptedKeyLen = 0;
static unsigned char symEncryptedKey[2048] = {
    0x30, 0x7a, 0x02, 0x21, 0x00, 0xa2, 0xf0, 0xfa, 0xe3, 0x79, 0xcc, 0x85, 0x44, 0xc7, 0x96, 0x93,
    0x78, 0x4e, 0x34, 0x51, 0xce, 0x50, 0xc8, 0xa4, 0x3b, 0xf7, 0x66, 0x95, 0x5a, 0x43, 0x2b, 0x26,
    0x9e, 0x3d, 0x72, 0xe7, 0x02, 0x02, 0x21, 0x00, 0xbf, 0xc6, 0x05, 0xdc, 0x68, 0x16, 0x8e, 0x7a,
    0x72, 0xad, 0xf3, 0x89, 0x12, 0x33, 0x2e, 0x35, 0xff, 0xa0, 0x8c, 0xa0, 0x90, 0x6f, 0x44, 0x85,
    0xbe, 0xea, 0xf3, 0xaf, 0xc8, 0xb4, 0x01, 0x19, 0x04, 0x20, 0x5c, 0x39, 0xb8, 0x29, 0x37, 0x4b,
    0x69, 0x67, 0x09, 0x76, 0x55, 0x0f, 0x7b, 0x2d, 0xa4, 0x9c, 0xcc, 0x9f, 0xd9, 0x94, 0x2e, 0x2f,
    0xf4, 0x78, 0x88, 0x57, 0xd1, 0x32, 0x46, 0xfa, 0x37, 0x0c, 0x04, 0x10, 0xc7, 0x3d, 0xb6, 0x17,
    0x8e, 0x06, 0x36, 0x09, 0x7f, 0x1e, 0x22, 0x6a, 0x17, 0x72, 0xc6, 0xfb
};

static int sm2PublicKeyLen = 0;
static unsigned char sm2PublicKey[2048] = {
    0x04, 0x77, 0x94, 0xbf, 0x71, 0x0a, 0xe5, 0xcf, 0xaa, 0xb1, 0x7d, 0x06, 0xaf, 0xa2, 0xb1, 0xd4,
    0xbc, 0x98, 0xb3, 0x78, 0x53, 0x1c, 0xea, 0x64, 0xe8, 0xc2, 0xd8, 0x37, 0x63, 0x2a, 0xdb, 0x90,
    0x8c, 0x87, 0xeb, 0x96, 0xe9, 0x07, 0x99, 0xf5, 0x4a, 0x5b, 0x45, 0xee, 0x96, 0x84, 0x30, 0x93,
    0x77, 0xf9, 0xca, 0x3c, 0xab, 0x22, 0xca, 0x62, 0x47, 0x35, 0x6d, 0x10, 0x72, 0xd5, 0xe2, 0x72,
    0x55
};

static int sm2EncryptedPrivateKeyLen = 0;
static unsigned char sm2EncryptedPrivateKey[2048] = {
    0x7c, 0xe1, 0x17, 0xf6, 0x5c, 0x26, 0x43, 0xea, 0xf0, 0xe2, 0xa1, 0x50, 0xab, 0xcd, 0x7e, 0x77,
    0x7c, 0xe1, 0x17, 0xf6, 0x5c, 0x26, 0x43, 0xea, 0xf0, 0xe2, 0xa1, 0x50, 0xab, 0xcd, 0x7e, 0x77,
    0x60, 0x93, 0x51, 0x65, 0x8e, 0x66, 0x11, 0xd1, 0x96, 0xa3, 0x72, 0xb6, 0xb7, 0x61, 0x20, 0x43,
    0x26, 0x19, 0xf9, 0xde, 0x8e, 0x6d, 0x47, 0xbd, 0x2d, 0x49, 0x0d, 0x98, 0x71, 0x6b, 0x24, 0xab
};

static int sm2envelopedkeyLen = 0;
static unsigned char sm2envelopedkey[2048] = {0};

// OID转换
static int oidHexLen = 9;
static unsigned char oidHex[2048] = {0x2a, 0x86 , 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x0b};

static int oidtxtLen = 0;
static char oidtxt[2048] = {0};

int main(int argc, char *argv[])
{
    int ret = 0;

#if 0
    OpenSSL_add_all_ciphers();
    OpenSSL_add_all_digests();
    OpenSSL_add_all_algorithms();
#endif

    // SM2加密
    ret = sm2cipher_encode(xCoordinate, 32, yCoordinate, 32, hash, 32, cipherText, 8, \
        sm2cipher, &sm2cipherLen);
    if(ret <= 0)
    {
        fprintf(stderr, "%s:%d %s - %d:%s\n", __FILE__, __LINE__, __FUNCTION__, errno, strerror(errno));
        goto EndP;
    }
    fprintf(stdout, "sm2cipher encode succeed:\n");
    PRINT_HEX(sm2cipher, sm2cipherLen);

    ret = sm2cipher_decode(sm2cipher, sm2cipherLen, xCoordinate, &xCoordinateLen, yCoordinate, &yCoordinateLen, \
        hash, &hashLen, cipherText, &cipherTextLen);
    if(ret <= 0)
    {
        fprintf(stderr, "%s:%d %s - %d:%s\n", __FILE__, __LINE__, __FUNCTION__, errno, strerror(errno));
        goto EndP;
    }
    fprintf(stdout, "sm2cipher decode succeed:\n");
    PRINT_HEX(xCoordinate, xCoordinateLen);
    PRINT_HEX(yCoordinate, yCoordinateLen);
    PRINT_HEX(hash, hashLen);
    PRINT_HEX(cipherText, cipherTextLen);

    // SM2签名
    ret = sm2signature_encode(r, 32, s, 32, sm2signature, &sm2signatureLen);
    if(ret <= 0)
    {
        fprintf(stderr, "%s:%d %s - %d:%s\n", __FILE__, __LINE__, __FUNCTION__, errno, strerror(errno));
        goto EndP;
    }
    fprintf(stdout, "sm2signature encode succeed:\n");
    PRINT_HEX(sm2signature, sm2signatureLen);

    ret = sm2signature_decode(sm2signature, sm2signatureLen, r, &rLen, s, &sLen);
    if(ret <= 0)
    {
        fprintf(stderr, "%s:%d %s - %d:%s\n", __FILE__, __LINE__, __FUNCTION__, errno, strerror(errno));
        goto EndP;
    }
    fprintf(stdout, "sm2signature decode succeed:\n");
    PRINT_HEX(r, rLen);
    PRINT_HEX(s, sLen);

    // SM2信封
    ret = sm2envelopedkey_encode(symAlgID, 7, symEncryptedKey, 124, sm2PublicKey, 65, sm2EncryptedPrivateKey, 64, sm2envelopedkey, &sm2envelopedkeyLen);
    if(ret <= 0)
    {
        fprintf(stderr, "%s:%d %s - %d:%s\n", __FILE__, __LINE__, __FUNCTION__, errno, strerror(errno));
        goto EndP;
    }
    fprintf(stdout, "sm2envelopedkey encode succeed:\n");
    PRINT_HEX(sm2envelopedkey, sm2envelopedkeyLen);

    ret = sm2envelopedkey_decode(sm2envelopedkey, sm2envelopedkeyLen, symAlgID, &symAlgIDLen, symEncryptedKey, &symEncryptedKeyLen, \
        sm2PublicKey, &sm2PublicKeyLen, sm2EncryptedPrivateKey, &sm2EncryptedPrivateKeyLen);
    if(ret <= 0)
    {
        fprintf(stderr, "%s:%d %s - %d:%s\n", __FILE__, __LINE__, __FUNCTION__, errno, strerror(errno));
        goto EndP;
    }
    fprintf(stdout, "sm2envelopedkey decode succeed:\n");
    PRINT_HEX(symAlgID, symAlgIDLen);
    PRINT_HEX(symEncryptedKey, symEncryptedKeyLen);
    PRINT_HEX(sm2PublicKey, sm2PublicKeyLen);
    PRINT_HEX(sm2EncryptedPrivateKey, sm2EncryptedPrivateKeyLen);

    // OID转换
    oidtxtLen = oid_hex2txt(oidHex, oidHexLen, oidtxt, 2048);
    fprintf(stdout, "%s\n", oidtxt);

    oidHexLen = oid_txt2hex(oidtxt, oidtxtLen, oidHex, 2048);
    PRINT_HEX(oidHex, oidHexLen);

    return 1;
EndP:
    ERR_print_errors_fp(stderr);
    return 0;
}
